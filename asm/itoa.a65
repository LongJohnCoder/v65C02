;===============================================================================
;Copyright (C) 2018 Ryan Clarke
;
;This program is free software (firmware): you can redistribute it and/or modify
;it under the terms of the GNU General Public License as published by
;the Free Software Foundation, either version 3 of the License, or
;(at your option) any later version.
;
;This program is distributed in the hope that it will be useful,
;but WITHOUT ANY WARRANTY; without even the implied warranty of
;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;GNU General Public License for more details.
;
;You should have received a copy of the GNU General Public License
;along with this program.  If not, see <http://www.gnu.org/licenses/>.
;===============================================================================


;===============================================================================
; Program   : v65C02 BIOS
; File Name : itoa.a65
; Project   : v65C02 8-bit Computer
; Author    : Ryan Clarke
; E-mail    : kj6msg@icloud.com
;===============================================================================
; Release History :
;
;    Version     | Date          | Description
;    -------------------------------------------------
;    0.0         | 08/15/2018    | Initial development
;===============================================================================
; Purpose : Integer-to-string conversion routine for the 65C02 BIOS.
;===============================================================================


.PC02

.EXPORT     itoa


;= CONVERT INTEGER TO STRING ===================================================
; Converts a 16-bit integer to a null terminated string.
;
; Parameters: X = integer<15:8>
;             A = integer<7:0>
; Returns:    X = &string<15:8>
;             A = &string<7:0>
;
; Cycles (jsr->rts): 296 (0) - 1590 (59999)

.CODE

itoa:       stx     $01
            sta     $00                 ; $0000 = 16-bit unsigned integer
            
            ldy     #0                  ; Y = places index (start at 10000s LSB)
            ldx     #0                  ; X = int_str index (start at 0)
            stz     $02                 ; $0002 = digit
            
@subtract:  lda     $00                 ; A = integer<7:0>
            sec                         ; 16-bit subtraction
            sbc     places, Y           ; A = integer<7:0> - place<7:0>
            sta     $03                 ; save result
            lda     $01                 ; A = integer<15:8>
            iny                         ; Y++
            sbc     places, Y           ; A = integer<15:8> - place<15:8>
            bmi     @next               ; $0000 - places[Y] < 0?
            
            sta     $01                 ; integer<15:8> -= place<15:8>
            lda     $03
            sta     $00                 ; integer<7:0> -= place<7:0>
            
            inc     $02                 ; digit++
            dey                         ; Y-- (back to place LSB)
            bra     @subtract
                        
@next:      lda     $02                 ; A = digit
            clc
            adc     #$30                ; A = digit + $30 ($30 = ASCII '0')
            sta     int_str, X          ; int_str[X] = digit + $30
            
            stz     $02                 ; digit = 0
            iny                         ; Y++ (next places LSB)
            inx                         ; X++ (next int_str digit)
            cpx     #4
            bcc     @subtract           ; X < 4?
            
@ones:      lda     $00                 ; A = 1s digit
            clc
            adc     #$30                ; A = 1s digit + $30 ($30 = ASCII '0')
            sta     int_str, X          ; int_str[4] = 1s digit + $30
            
            ldx     #0                  ; Y = 0
@zeros:     lda     int_str, X          ; A = int_str[X]
            cmp     #$30                ; ASCII '0'
            bne     @done               ; int_str[X] != '0'?
            
            inx                         ; X++
            cpx     #4
            bcc     @zeros              ; X < 4?

@done:      stz     int_str+5           ; int_str[5] = 0 (NUL terminator)
            txa                         ; A = offset into integer string
            clc
            adc     #.LOBYTE(int_str)   ; A = &integer<7:0> + offset
            ldx     #.HIBYTE(int_str)   ; X = &integer<15:8>
            
            rts


;= READ ONLY DATA ==============================================================

.RODATA

; ten-thousands, thousands, hundreds, and tens places
places:     .WORD 10000, 1000, 100, 10


;= UNINITIALIZED DATA ==========================================================

.BSS

int_str:    .RES 6                      ; 5 digits plus a NUL terminator
