;===============================================================================
;Copyright (C) 2018 Ryan Clarke
;
;This program is free software (firmware): you can redistribute it and/or modify
;it under the terms of the GNU General Public License as published by
;the Free Software Foundation, either version 3 of the License, or
;(at your option) any later version.
;
;This program is distributed in the hope that it will be useful,
;but WITHOUT ANY WARRANTY; without even the implied warranty of
;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;GNU General Public License for more details.
;
;You should have received a copy of the GNU General Public License
;along with this program.  If not, see <http://www.gnu.org/licenses/>.
;===============================================================================


.PC02

.INCLUDE "memory.inc"

.EXPORT itoa


;= UNSIGNED 16-BIT INTEGER TO STRING ===========================================
; Converts an unsigned 16-bit integer to a null-terminated string using the
; double dabble algorithm to first convert to BCD and then a conversion to
; ACII.
;
; Parameters: X = &integer<15:8>
;             A = &integer<7:0>
; Returns:    X = &string<15:8>
;             A = &string<7:0>
;
; Cycles (jsr->rts): 2067-3188

.CODE

itoa:       stz     string                  ; set BCD bytes to 0
            stz     string+1
            stz     string+2
            stx     string+3                ; integer bytes furthest to the
            sta     string+4                ; right
            
            ; double-dabble to convert binary to BCD
            ldy     #16                     ; Y = 16 bits, 16 shifts
@dabble:    ldx     #2                      ; X = BCD packed byte counter
@lonibble:  lda     string, X
            and     #$0F                    ; low nibble first
            cmp     #$05
            bcc     @hinibble               ; low nibble < 5?
            
            lda     string, X               ; low nibble is greater than 4
            clc
            adc     #$03                    ; add three to nibble
            sta     string, X               ; save back to BCD byte
            
@hinibble:  lda     string, X
            and     #$F0                    ; high nibble
            cmp     #$50
            bcc     @next                   ; high nibble < 5?
            
            lda     string, X               ; high nibble is greater than 4
            clc
            adc     #$30                    ; add three to nibble
            sta     string, X               ; save back to BCD byte
            
@next:      dex                             ; nexy BCD packed byte
            bpl     @lonibble               ; X < 0?

            asl     string+4                ; 5 byte left shift
            rol     string+3
            rol     string+2
            rol     string+1
            rol     string
            
            dey                             ; shift counter--
            bne     @dabble                 ; Y > 0?
            
            ; convert BCD to ASCII
            ldx     #2                      ; X = BCD packed byte counter
            ldy     #4                      ; Y = null-terminated string counter
@toascii:   lda     string, X               ; load BCD byte
            and     #$0F                    ; low nibble first
            ora     #'0'                    ; map 0-9 to "0"-"9"
            sta     string, Y               ; store ASCII value
            
            dey                             ; next string position
            lda     string, X               ; load BCD byte
            lsr     A                       ; high nibble shift
            lsr     A
            lsr     A
            lsr     A
            ora     #'0'                    ; map 0-9 to "0"-"9"
            sta     string, Y               ; store ASCII value
            
            dey                             ; next string position
            dex                             ; next BCD byte
            bne     @toascii                ; byte > 0?
            
            lda     string                  ; last BCD byte (low nibble only)
            ora     #'0'                    ; map first digit to "0"-"9"
            sta     string                  ; store ASCII value
            
            stz     string+5                ; null terminator
            
            ; remove leading zeros
            lda     #.HIBYTE(string)
            sta     $01
            lda     #.LOBYTE(string)
            sta     $00                     ; ($00) = &string
            
            ldx     #4                      ; check the first 4 digits
@zeros:     lda     ($00)                   ; load ASCII digit
            cmp     #'0'
            bne     @done                   ; ASCII digit == '0'?
            
            inc     $00                     ; next ASCII digit
            dex                             ; digit counter--
            bne     @zeros                  ; digit counter > 0?
            
@done:      ldx     $01                     ; return value = &string
            lda     $00
            
            rts


;= UNINITIALIZED DATA ==========================================================

.BSS

string:     .RES 6          ; doubles as BCD storage and ASCII string
    